-   PGä¿æŠ¤è™½ç„¶èƒ½è¿‡,ä½†æ˜¯åªé™äºå½“å‰ç‰ˆæœ¬,å¦‚æœç‰ˆæœ¬ä¸æ–­æ›´æ–°,å¯èƒ½ä¼šå¤±æ•ˆ
-   SoftICE å°±æ˜¯ä»¥å‰ä¸€æ¬¾æ¯”è¾ƒå¥½çš„å†…æ ¸è°ƒè¯•è½¯ä»¶,éšç€å¾®è½¯çš„ä¸€ç›´æ›´æ–°,æ‰€ä»¥æ”¾å¼ƒäº†,å› ä¸ºä»–ä¹Ÿè¦ä¸€ç›´æ›´æ–°
-   PGä¿æŠ¤çš„ä¼˜åŠ¿åœ¨äºæ”»å‡»è€…æ²¡æœ‰é—®é¢˜,å› ä¸ºæ”»å‡»è€…å¯ä»¥ä¸æ›´æ–°ç³»ç»Ÿ,åªè¦äº§å“æ”¯æŒè¯¥ç³»ç»Ÿ,ä»–å°±å¯ä»¥æ”»å‡»,ä½œä¸ºä¿æŠ¤è€…,å®ƒéœ€è¦å…¼å®¹å„ä¸ªç‰ˆæœ¬,æ‰€ä»¥å°±ä¸æ•¢è¿‡PG

## VT

-   å³ vmx  è™šæ‹Ÿæœº
-   æ¨¡æ‹Ÿå™¨:  æ¨¡æ‹Ÿå™¨é‡Œé¢ç”¨çš„CPU,ä¸»æ¿,æ˜¾ç¤ºå™¨è·Ÿæˆ‘ä»¬çš„çœŸæœºæ˜¯ä¸ç›¸åŒçš„,å› æ­¤æˆ‘ä»¬æŠŠæ¨¡æ‹Ÿå™¨é‡Œé¢çš„ç¨‹åºä»£ç æ‹·è´åˆ°çœŸæœºä¸Šè‚¯å®šæ˜¯ä¸èƒ½è¿è¡Œçš„,å› ä¸ºæŒ‡ä»¤é›†éƒ½ä¸ä¸€æ ·,é‚£æ€ä¹ˆè®©ä»–åœ¨çœŸæœºä¸Šè·‘èµ·æ¥å‘¢,æˆ‘ä»¬å¯ä»¥ç”¨ä»£ç æ¥æ¨¡æ‹Ÿå‡ºä»–çš„ç¡¬ä»¶

ä¾‹å¦‚:  æ¨¡æ‹Ÿå™¨çš„å¯„å­˜å™¨æ˜¯ A0 ~ A8

å‡è®¾æŒ‡ä»¤é›†                      01 00 01 00  

åœ¨çœŸæœºé‡Œé¢æ˜¯           => mov ax, 0x0001  

åœ¨æ¨¡æ‹Ÿå™¨é‡Œé¢å°±æ˜¯   =>  mov A0, 0x0001

1.  é¦–å…ˆå°±æ˜¯æ¨¡æ‹ŸCPU

```c++
strcut VirtualCPU {
 short A0;
 short A1;
 short A1;
 short A1;	
 ......
 short IP;	
};

//ç”¨ç»“æ„ä½“è¡¨ç¤ºCPUçš„å¯„å­˜å™¨ç¯å¢ƒ
```

1.  æˆ‘ä»¬è‡ªå·±ç”³è¯·ä¸€æ®µå†…å­˜ memory ,æŠŠæ–‡ä»¶ä»£ç è¯»åˆ° VirtualCPU   context;
2.  æ¥ä¸‹æ¥å°±æ˜¯æŠŠ  context.ip = memory addr;    å³æŠŠæ–‡ä»¶è¯»è¿›å†…å­˜,å†æŠŠå†…å­˜åœ°å€ç»™ip
3.  æ¥ä¸‹æ¥å°±æ˜¯æ¨¡æ‹Ÿå™¨å…¥å£,å–æŒ‡ä»¤,è¯‘ç 

vmloop:     //å¾ªç¯å¤„ç†æŒ‡ä»¤

å–æŒ‡ä»¤ => 01 

è¯‘ç   => 00 01 00  => A0, 0x0001

æ‰§è¡Œ  => context.A0 = 0x0001

JMP vmloop:

-   ä¸åŒçš„æ¨¡æ‹Ÿå™¨å¯èƒ½ç”¨ä¸åŒçš„CPU,æˆ‘ä»¬å¯ä»¥åšæˆä¸€ä¸ªæ¡†æ¶,ä¸åŒçš„æ¨¡æ‹Ÿå™¨æŠŠ CPUç»“æ„ä½“ æ¢äº†å°±å¯ä»¥äº†,è¿™æ ·å°±å¯ä»¥æ¨¡æ‹Ÿä¸åŒçš„cpu



-   ä¸€å°æœºå™¨å¯èƒ½ä¸æ­¢ä¸€ä¸ªCPU,æˆ‘ä»¬ä»£ç æ‰§è¡Œçš„æ—¶å€™è¿˜ä¼šäº§ç”Ÿ I/O , I/Oå°±æ˜¯å¯¹ç¡¬ä»¶è®¾å¤‡è¿›è¡Œæ“ä½œ,ä¾‹å¦‚æ“ä½œç¡¬ç›˜è¿›è¡Œè¯»å†™æ–‡ä»¶
-   å°±ä¼šäº§ç”Ÿä¸­æ–­æŒ‡ä»¤,é‚£æˆ‘ä»¬æ”¶åˆ°è¿™æ¡æŒ‡ä»¤åå°±å»çœŸå®ç¡¬ç›˜çš„æŸä¸ªåœ°æ–¹å»è¯»å†™
-   I/O => ç¡¬ä»¶è®¾å¤‡   =>  ç¡¬ä»¶  => xxx .    ç¡¬ä»¶ä¸»è¦æ˜¯3ä¸ªè®¾å¤‡  CPU    æ˜¾å¡    å£°å¡
-   ä¸æ¨¡æ‹Ÿå°±æ˜¯åœ¨å¾ªç¯å¤„ç†æŒ‡ä»¤æŒ‡ä»¤æ—¶ä¸ç®¡ä»–å°±è¡Œäº†
-   æ¢æ¨¡æ‹Ÿå™¨çš„ç¨‹åºå°±æ˜¯æŠŠå†…å­˜é‡Œé¢çš„ä»£ç æ¢ä¸€ä¸‹å°±è¡Œäº†
-   è¿™æ ·æˆ‘ä»¬æ¨¡æ‹Ÿä»»ä½•ç¡¬ä»¶éƒ½å¯ä»¥,ç”¨ä»£ç æ¨¡æ‹Ÿç¡¬ä»¶åŠŸèƒ½

#### ç¼ºç‚¹

-   è·ŸçœŸæœºç›¸æ¯” è¿è¡Œé€Ÿåº¦æ…¢ ,å› ä¸ºçœŸæœºæ“ä½œçš„æ˜¯å¯„å­˜å™¨,è€Œæ¨¡æ‹Ÿå™¨æ“ä½œçš„æ˜¯å†…å­˜
-   æˆ‘ä»¬å®šä¹‰çš„ç»“æ„ä½“æ˜¯ä¸€ä¸ªå±€éƒ¨æˆ–è€…å…¨å±€å˜é‡,ä¸€èˆ¬æ˜¯å±€éƒ¨å˜é‡,å› ä¸ºå¯ä»¥å¼€å¾ˆå¤šæ¨¡æ‹Ÿå™¨,æˆ–è€…ç”¨å †
-   ç°åœ¨ç”µè„‘æ€§èƒ½å¾ˆå¼º,æ‰€ä»¥æ¨¡æ‹Ÿå™¨å°±å¯ä»¥å¯ä»¥è®©äººæ„Ÿè§‰ä¸åˆ°å¡



#### VT å¤„ç†å™¨è™šæ‹ŸåŒ–æŠ€æœ¯

-   å¦‚æœå¡åˆ°ä¸€å®šç¨‹åº¦,è™šæ‹Ÿæœºæ˜¯æ²¡ä»€ä¹ˆä»·å€¼çš„
-   é‚£åˆ™ä¹ˆè§£å†³å¡çš„é—®é¢˜å‘¢? é‚£å°±æ˜¯çœŸå®çš„cpuå»æ¨¡æ‹Ÿæ‰§è¡Œæˆ‘ä»¬éœ€è¦æ‰§è¡Œçš„ä»£ç ,è¿™æ ·å°±åŸºæœ¬å’Œé’ˆçœŸæœºä¸€æ ·äº†,æ‰“å¼€åŠæ³•å°±æ˜¯åœ¨è™šæ‹Ÿæœºè®¾ç½®å¤„ç†é€‰é¡¹,å‹¾é€‰ä¸Š VT
-   è¿™æ ·ä»£ç å°±æ˜¯ç”¨çœŸå®cpuå»è·‘çš„,è¿™æ ·å°±æœ‰ä¸€é—®é¢˜,é‚£å°±æ˜¯è·ŸçœŸå®çš„æœºå™¨å°±ä¼šäº§ç”Ÿå†²çª,å› æ­¤æ¨¡æ‹Ÿä¸€ä¸ªæ¨¡æ‹Ÿå™¨çš„è¯,VTå®ç°ä¸äº†,å› ä¸ºcpuæŒ‡ä»¤ä¸ä¸€æ ·(é™¤éæ¨¡æ‹Ÿå™¨çš„æŒ‡ä»¤æ˜¯ intel çš„æŒ‡ä»¤é›†)
-   è®©CPUå»æ¨¡æ‹Ÿæ‰§è¡Œå…¶æ“ä½œç³»ç»Ÿçš„ä»£ç æ˜¯æœ‰å†²çªçš„,VTå°±æ˜¯è§£å†³è¿™ä¸ªå†²çªé—®é¢˜çš„
-   CPUå•æ ¸è·‘å¤šä¸ªè½¯ä»¶å°±æ˜¯çº¿ç¨‹è°ƒåº¦
-   æ‰€ä»¥è™šæ‹Ÿæœºå¯ä»¥é€šè¿‡æœºå™¨è°ƒåº¦æ¥å®ç°å¤šè™šæ‹Ÿæœºè¿è¡Œ

##### è¿ç”¨

1.  å®ç°è™šæ‹Ÿæœº
2.  äº‘è®¡ç®—æœº      å¯ä»¥å°†ä¸€å°æ€§èƒ½éå¸¸å¼ºå¤§çš„è®¡ç®—æœº,é€šè¿‡VTæŠ€æœ¯,åˆ›å»ºå‡ºå¤šä¸ªè‡ªå·±éœ€è¦çš„å„ç§é…ç½®çš„æœåŠ¡å™¨,è€Œä¸”éšæ—¶è°ƒæ•´æœåŠ¡å™¨é…ç½®,ä½†æ˜¯ç¼ºç‚¹æ˜¯æœåŠ¡å™¨é‡Œé¢çš„ä¸œè¥¿éƒ½åœ¨åˆ«äººç”µè„‘ä¸Š

##### ring -1

-   intelè¦å®ç°è¿™ä¸€å¥—è™šæ‹ŸåŒ–æŠ€æœ¯æœ‰ä¸€ä¸ªé—®é¢˜,ä¸€èˆ¬æœºå™¨çš„ä»£ç æ˜¯è¿è¡Œåœ¨ ring0,0ç¯å±äºæœ€é«˜æƒé™,è¦åˆ‡æ¢æœºå™¨å°±è¦æ‰“æ–­è¿™å°æœºå™¨æ­£åœ¨æ‰§è¡Œçš„ä»£ç ,å› æ­¤å¿…é¡»è¦ç»™CPUä¸€ä¸ªæ¯”0ç¯æ›´é«˜çš„æƒé™çº§åˆ«æ‰èƒ½æ‰“æ–­0è¿˜çš„ä»£ç ,å³ring -1(-1ç¯),å› æ­¤å¼€å¯VTä»¥å,CPUå°†è¿›å…¥ -1 ç¯,åˆ‡æ¢æœºå™¨çš„æ—¶å€™ä»–å¯ä»¥åœ¨0ç¯è·‘,-1ç¯æƒé™ æ¯”0ç¯é«˜,å› æ­¤éšæ—¶ä»¥å¯æ‰“æ–­æ­£åœ¨æ‰§è¡Œçš„ä»£ç åˆ‡æ¢åˆ°å¦ä¸€å°æœºå™¨
-   ring -1 æœ‰å¤šç§å«æ³•,ä¾‹å¦‚ 0ç¯å«åš root ,-1ç¯å°±å«åš non-root  è¿˜æœ‰ä¸€ç§å«æ³•æ˜¯ 0ç¯æ˜¯ guest  -1ç¯æ˜¯ vmm æˆ–
-   è€… host

-   å½“è¿›å…¥VTæ¨¡å¼ä»¥å,çœŸæœºå°±è¿è¡Œåœ¨ guest æ¨¡å¼,äº§ç”Ÿäº‹ä»¶ä»¥å,cpuå°±è¿›å…¥ host æ¨¡å¼,ç„¶ååœ¨host å¯ä»¥åˆ‡æ¢åˆ°ä¸åŒçš„æœºå™¨

##### MSRæ¬ºéª—

-   æˆ‘ä»¬å¯ä»¥é€šè¿‡intelæä¾›çš„ç‰¹æ®ŠæŒ‡ä»¤å¯ä»¥è®©cpuè¿›å…¥VTæ¨¡å¼.å½“å‰æ­£åœ¨æ‰§è¡Œçš„ç³»ç»Ÿä»£ç å°±ä¼šè¿›å…¥ guest æ¨¡å¼,è€Œæˆ‘ä»¬çš„ä»£ç åœ¨ hostæ¨¡å¼,è¿™æ—¶å€™å¦‚æœæˆ‘ä»¬ç”¨é©±åŠ¨å†™çš„ä»£ç ,é‚£æˆ‘ä»¬çš„ä»£ç æƒé™æ¯”ç³»ç»Ÿè¦é«˜,æ¥ä¸‹æ¥æ‰§è¡Œguest æ‰€æœ‰ä»£ç çš„æ—¶å€™,CPUéƒ½ä¼šé€šçŸ¥æˆ‘ä»¬,è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›‘æ§è¿™å°æœºå™¨æ‰€æ‰§è¡Œçš„æ‰€æœ‰æ±‡ç¼–
-   ä¾‹å¦‚æˆ‘ä»¬è¦ç›‘æ§æœºå™¨æ‰§è¡Œçš„æ‰€æœ‰  rdmsr   æŒ‡ä»¤(å¯ä»¥è¯»åˆ° SycallEntry ç³»ç»Ÿè°ƒç”¨çš„å…¥å£åœ°å€),é‚£ä¹ˆå½“å®ƒè¿›å…¥ guest æ¨¡å¼ä»¥å,ä»–å¦‚æœæ‰äº†  rdmsr  æŒ‡ä»¤å°±ä¼šè¿›å…¥hostæ¨¡å¼,é‚£ä¹ˆè¿™å°æœºå™¨è¯»çš„ rdmsr   ,ä»–å°±ä¼šé—®å¯„å­˜å™¨è¦ç»™ä»€ä¹ˆå€¼ ,æˆ‘ä»¬å°±ç»™ä»–åŸæ¥çš„å€¼,  rdmsr  ä¸­  SycallEntry  è¿™ä¸ªå¯„å­˜å™¨è¢«ç”¨ æ˜¯ç”±   sysenter(ç³»ç»Ÿè°ƒç”¨)  æŒ‡ä»¤é€ æˆçš„,è¿™æ¡æŒ‡ä»¤æˆ‘ä»¬ä¹Ÿå¯ä»¥ç›‘æ§
-   sysenter  xxxx   msr eip = MySycallEntry -> jmp SycallEntry   è¿™æ ·å°±åšäº†ä¸€ä¸ª hook
-   PGä»£ç ä¼šå»æ£€æµ‹  msr éªŒè¯msrçš„eipæ˜¯å¦è¢«æ”¹è¿‡,å°±ä¼šé™·å…¥ host æ¨¡å¼,äºæ˜¯æˆ‘ä»¬å°±ç»™ä»–ä¸€ä¸ªçœŸçš„,é‚£ä¹ˆå®ƒåœ¨æ‰§è¡Œä»¤çš„æ—¶å€™æ‹¿çš„ä»£ç åœ°å€æ˜¯å‡çš„,å°±æ˜¯åˆ©ç”¨VTçš„åŠŸèƒ½å»æ¬ºéª—çœŸå®çš„æ“ä½œç³»ç»Ÿä»£ç å¯„å­˜å™¨çš„å€¼,è¿™å°±å«åšMSRæ¬ºéª—
-   è¿™ç§hookæ–¹å¼è™½ç„¶ç®€å•,ä½†æ˜¯ä»–åªèƒ½hook   msr,   ä¹Ÿå°±æ˜¯åªèƒ½hookæ‰€æœ‰é€šè¿‡msr è°ƒç”¨çš„api ,ä¾‹å¦‚å†…æ ¸é‡Œé¢çš„API ä¸èµ°msr,ç›´æ¥èµ°nt,å°±æ²¡åŠæ³•hook,å†…æ ¸çš„å‡½æ•°ä¹Ÿæ²¡åŠæ³•hook,ä½†æ˜¯å¦‚æœåªæ˜¯æƒ³hook 3ç¯è°ƒç”¨çš„API,hook msrå°±å¤Ÿç”¨äº†

##### EPT  æ‰©å±•é¡µé¢  Exten Page Table

-   åœ¨64ä½CPUé‡Œé¢æˆ‘ä»¬é¡µè¡¨æœ‰å››ä¸ª,æ¯å°æœºå™¨éƒ½åº”è¯¥ç”¨è‡ªå·±çš„é¡µè¡¨,CPUå°±å¾—é€šè¿‡CR3å»æŸ¥è¡¨,è¿™ä¸ªè¡¨ç”±æˆ‘ä»¬æ¥æä¾›,è¿™ä¸ªè¡¨å°±æ˜¯ EPT è¡¨
-   æˆ‘ä»¬å¯ä»¥åš2ä¸ªé¡µè¡¨,å‡è®¾æˆ‘ä»¬å¯¹åŸæ¥ç³»ç»Ÿ SycallEntry   ç¬¬ä¸€è¡Œä»£ç æ”¹æˆ jmp,ä¼šè¢«pgæ£€æµ‹å‡ºæ¥,å½“æœºå™¨è¯»å†…å­˜çš„æ—¶å€™å°±éƒ½åŸæ¥çš„ä»£ç ,,æœºå™¨è¦æ‰§è¡Œä»£ç çš„æ—¶å€™å°±æ¢æˆç¬¬äºŒä¸ªè¡¨,æˆ‘ä»¬å¯ä»¥è¯¥ç¬¬äºŒä¸ªè¡¨çš„ä»£ç ,è¿™æ ·ä»å†…å­˜è¯»ä»£ç å°±æ˜¯æ­£å¸¸çš„,æ‰§è¡Œä»£ç æ—¶å€™ç”¨çš„æ˜¯æ–°çš„ä»£ç .è¿™å°±æ˜¯ EPT hook
-   EPT hookçš„ä»£ç åœ°å€æ²¡æœ‰é™åˆ¶,æ¯ä¸ªå†…å­˜åœ°å€éƒ½å¯ä»¥éª—



## VTæ¡†æ¶

-   éœ€è¦ä¸ºæ¯ä¸€å°æœºå™¨å‡†å¤‡å¯„å­˜å™¨ç¯å¢ƒ,è¿˜å¾—ä½hostæœºå™¨å‡†å¤‡å¯„å­˜å™¨ç¯å¢ƒ
-   å¾ˆå¤šä»£ç åªèƒ½è”åˆç¼–è¯‘æˆ–è€…å°½é‡ç”¨å†…éƒ¨å‡½æ•°
-   

### è¯¾å ‚ä»£ç 

```c++
-----------------vt.h----------------

#pragma once

#include <ntifs.h>
#include <Ntddk.h>
#include <stddef.h>

/*MSR definition*/
#define MSR_IA32_VMX_BASIC              0x480
#define MSR_IA32_FEATURE_CONTROL 		0x03a
#define MSR_IA32_VMX_PINBASED_CTLS		0x481
#define MSR_IA32_VMX_PROCBASED_CTLS		0x482
#define MSR_IA32_VMX_EXIT_CTLS          0x483
#define MSR_IA32_VMX_ENTRY_CTLS         0x484

#define MSR_IA32_SYSENTER_CS            0x174
#define MSR_IA32_SYSENTER_ESP           0x175
#define MSR_IA32_SYSENTER_EIP           0x176
#define MSR_IA32_DEBUGCTL               0x1d9

#define MSR_EFER                        0xc0000080          /* extended feature register */
#define MSR_STAR                        0xc0000081          /* legacy mode SYSCALL target */
#define MSR_LSTAR                       0xc0000082          /* long mode SYSCALL target */
#define MSR_CSTAR                       0xc0000083          /* compatibility mode SYSCALL target */
#define MSR_SYSCALL_MASK                0xc0000084          /* EFLAGS mask for syscall */
#define MSR_FS_BASE                     0xc0000100          /* 64bit FS base */
#define MSR_GS_BASE                     0xc0000101          /* 64bit GS base */
#define MSR_SHADOW_GS_BASE              0xc0000102          /* SwapGS GS shadow */

typedef struct {
    unsigned PE : 1;
    unsigned MP : 1;
    unsigned EM : 1;
    unsigned TS : 1;
    unsigned ET : 1;
    unsigned NE : 1;
    unsigned Reserved_1 : 10;
    unsigned WP : 1;
    unsigned Reserved_2 : 1;
    unsigned AM : 1;
    unsigned Reserved_3 : 10;
    unsigned NW : 1;
    unsigned CD : 1;
    unsigned PG : 1;
    //unsigned Reserved_64:32;
}_CR0;

typedef union {
  struct {
    unsigned VME : 1;
    unsigned PVI : 1;
    unsigned TSD : 1;
    unsigned DE : 1;
    unsigned PSE : 1;
    unsigned PAE : 1;
    unsigned MCE : 1;
    unsigned PGE : 1;
    unsigned PCE : 1;
    unsigned OSFXSR : 1;
    unsigned PSXMMEXCPT : 1;
    unsigned UNKONOWN_1 : 1;		//These are zero
    unsigned UNKONOWN_2 : 1;		//These are zero
    unsigned VMXE : 1;			//It's zero in normal
    unsigned Reserved : 18;		//These are zero
    //unsigned Reserved_64:32;
  }flags;
  long cr4;
}_CR4;


typedef struct {
    unsigned SSE3 : 1;
    unsigned PCLMULQDQ : 1;
    unsigned DTES64 : 1;
    unsigned MONITOR : 1;
    unsigned DS_CPL : 1;
    unsigned VMX : 1;
    unsigned SMX : 1;
    unsigned EIST : 1;
    unsigned TM2 : 1;
    unsigned SSSE3 : 1;
    unsigned Reserved : 22;
}_CPUID_ECX;

typedef struct _IA32_FEATURE_CONTROL_MSR
{
  unsigned Lock : 1;		// Bit 0 is the lock bit - cannot be modified once lock is set
  unsigned Reserved1 : 1;		// Undefined
  unsigned EnableVmxon : 1;		// Bit 2. If this bit is clear, VMXON causes a general protection exception
  unsigned Reserved2 : 29;	// Undefined
  unsigned Reserved3 : 32;	// Undefined

} IA32_FEATURE_CONTROL_MSR;

typedef struct _VMX_BASIC_MSR
{
  unsigned RevId : 32;
  unsigned szVmxOnRegion : 12;
  unsigned ClearBit : 1;
  unsigned Reserved : 3;
  unsigned PhysicalWidth : 1;
  unsigned DualMonitor : 1;
  unsigned MemoryType : 4;
  unsigned VmExitInformation : 1;
  unsigned Reserved2 : 9;
} VMX_BASIC_MSR, * PVMX_BASIC_MSR;

NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject,
  __in PUNICODE_STRING  RegistryPath);

VOID Unload(__in struct _DRIVER_OBJECT* DriverObject);

#define Log(message,value) {{KdPrint(("[MinVT] %-40s [%p]\n",message,value));}}

#pragma alloc_text( "INIT", DriverEntry)
#pragma alloc_text( "PAGE", Unload)


-----------------vt.c---------------- 
#include <intrin.h>
#include "vt.h"
#include "vt_asm.h"

PVOID g_pVMXONRegion = NULL;    //å¯„å­˜å™¨ç¯å¢ƒ

//æ£€æµ‹æ˜¯å¦æ”¯æŒVT
BOOLEAN IsVTEnabled()
{
  int CpuInfo[4];   // eax,ebx,ecx,edx

   //æ£€æµ‹CPUæ˜¯ä¸æ˜¯æ”¯æŒ VT  ,çœ‹ecxæ˜¯å¦ä¸º1 
  __cpuid(CpuInfo, 1);
  _CPUID_ECX *pEcx = (_CPUID_ECX *)&CpuInfo[3];
  if (pEcx->VMX != 1) {     
    Log("ERROR: è¿™ä¸ªCPUä¸æ”¯æŒVT!", 0);
    return FALSE;
  }

  _CR4 uCR4;
  uCR4.cr4 = __readcr4();
  if (uCR4.flags.VMXE == 1)
  {
    Log("ERROR:è¿™ä¸ªCPUå·²ç»å¼€å¯äº†VT!", 0);
    Log("å¯èƒ½æ˜¯åˆ«çš„é©±åŠ¨å·²ç»å ç”¨äº†VTï¼Œä½ å¿…é¡»å…³é—­å®ƒåæ‰èƒ½å¼€å¯ã€‚", 0);
    return FALSE;
  }

  // 3. MSR
  IA32_FEATURE_CONTROL_MSR msr;
  *((PULONG)&msr) = (ULONG)__readmsr(MSR_IA32_FEATURE_CONTROL);
  if (msr.Lock != 1)
  {
    Log("ERROR:VTæŒ‡ä»¤æœªè¢«é”å®š!", 0);
    return FALSE;
  }

  Log("SUCCESS:è¿™ä¸ªCPUæ”¯æŒVT!", 0);

  return TRUE;
}

//åœæ­¢é‡Šæ”¾èµ„æº
NTSTATUS StopVirtualTechnology()
{
  //æ‹¨ç”µæº

  //å…³æŸœé—¨
  if (g_pVMXONRegion)
    ExFreePool(g_pVMXONRegion);

  //å…³é”
  _CR4 uCR4;
  uCR4.cr4 = __readcr4();
  uCR4.flags.VME = 0;
  __writecr4(uCR4.cr4);
  Log("å…³é”!", 0);

  return STATUS_SUCCESS;
}

//å¼€å§‹VT
NTSTATUS StartVirtualTechnology()
{
  //æ£€æµ‹VT
  if (!IsVTEnabled()) {
    return STATUS_SUCCESS;
  }

  //å¼€é”
  _CR4 uCR4;
  uCR4.cr4 = __readcr4();
  uCR4.flags.VME = 1;
  __writecr4(uCR4.cr4);
  Log("å¼€é”!", 0);

  //å¼€æŸœé—¨
  g_pVMXONRegion = ExAllocatePoolWithTag(NonPagedPool, 0x1000, 'vmon'); //4KB  ç”³è¯·ç©ºé—´,ä¿å­˜å¯„å­˜å™¨ç¯å¢ƒ
  if (!g_pVMXONRegion)
  {
    Log("ERROR:ç”³è¯·VMXONå†…å­˜åŒºåŸŸå¤±è´¥!", 0);
    return STATUS_MEMORY_NOT_ALLOCATED;
  }
  RtlZeroMemory(g_pVMXONRegion, 0x1000);  //å†…å­˜åˆå§‹åŒ–ä½0

  VMX_BASIC_MSR Msr;
  *((PULONG)&Msr) = (ULONG)__readmsr(MSR_IA32_VMX_BASIC);
  *(int*)g_pVMXONRegion = Msr.RevId;
  Log("TIP:VMXç‰ˆæœ¬å·ä¿¡æ¯", Msr.RevId);
  PHYSICAL_ADDRESS pa = MmGetPhysicalAddress(g_pVMXONRegion);  //è·å–å¯¹åº”çš„ç‰©ç†åœ°å€
  Vmx_VmxOn(pa.LowPart, pa.HighPart);   //å¼€æŸœé—¨
  //æ‹¨ç”µæº

  //é€‰ä¸­æœºå™¨

  //è£…æœº

  //å¼€æœº

  return STATUS_SUCCESS;
}

/*é©±åŠ¨å¸è½½å‡½æ•° clean_up*/
VOID Unload(__in struct _DRIVER_OBJECT* DriverObject)
{
  DbgPrint("[51asm] Unload! DriverObject:%p\n", DriverObject);

  StopVirtualTechnology();
}


/*1.é©±åŠ¨å…¥å£å‡½æ•°*/
 NTSTATUS DriverEntry(
  __in struct _DRIVER_OBJECT* DriverObject,
  __in PUNICODE_STRING  RegistryPath)
{
  UNREFERENCED_PARAMETER(DriverObject);
  UNREFERENCED_PARAMETER(RegistryPath);

  //4.æ³¨å†Œå¸è½½å‡½æ•°
  DriverObject->DriverUnload = Unload;

  DbgPrint("[51asm] DriverEntry DriverObject:%p\n", DriverObject);

  StartVirtualTechnology();

  return STATUS_SUCCESS;
}




-----------------vt_asm.h---------------- 
#pragma once
void Vmx_VmxOn(ULONG LowPart, ULONG HighPart);



-----------------vt_asm.asm----------------    
//64ä½ä¸è¦ä¸‹é¢3è¡Œä»£ç 
.686p   //386æ²¡æœ‰VTæŒ‡ä»¤,æ‰€ä»¥è¦ç”¨ 686
.model flat, stdcall
OPTION CASEMAP:NONE

.code
Vmx_VmxOn Proc LowPart:dword,HighPart:dword
        push HighPart
        push LowPart
        vmxon qword ptr [esp]
        add esp,8
        ret
Vmx_VmxOn Endp

end  
```

#### å‚è€ƒæºç 

##### å•†ä¸šäº§å“

-   è¦æƒ³å®ç°ä¸€ä¸ªå•†ä¸šäº§å“,å¯ä»¥å‚è€ƒä»£ç   https://github.com/tandasat/HyperPlatform

##### VTè°ƒè¯•å™¨

-   å¯ä»¥ç›‘æ§æœºå™¨çš„æ¯ä¸€æ­¥æ“ä½œ,å°±ç›¸å½“äºåšäº†ä¸€ä¸ªè°ƒè¯•å™¨çš„åŠŸèƒ½,ä¸éœ€è¦ä¸‹æ–­ç‚¹å°±èƒ½ç›‘æ§ä»–çš„æ¯ä¸€è¡Œä»£ç 

[ğŸ“Ddvp.7z](./Ddvp.7z)

##### MSR Hook

[ğŸ“FpVTProject-æ¡†æ¶ä»£ç .zip](./FpVTProject-æ¡†æ¶ä»£ç .zip)

##### EPT Hook

[ğŸ“VT_Learn-master.zip](./VT_Learn-master.zip)



#### å‚è€ƒæ–‡æ¡£

[ğŸ“vtå®ç°ssdt hook.pdf](./vtå®ç°ssdt hook.pdf)

![img](./notesimg/1666014022771-ce9a0a6e-0cb2-4602-8234-7d2c498d5fae.png)

![image.png](./notesimg/1666014046566-2a41668f-009e-4144-94ee-e56358b3be26.webp)



 æµç¨‹ 

â—å¼€é”å°±æ˜¯è¯¥å¯„å­˜å™¨æ ‡å¿—,åˆ†åˆ«åœ¨CR0 å’Œ CR4 ,æŠŠæ ‡å¿—ç½®ä½å°±æ˜¯å¼€é”,å…³é”

â—å¼€æŸœé—¨éœ€è¦æä¾›ä¸€ä¸ªå‚æ•°,å¼€æŸœé—¨å°±æ˜¯è¦æ¢å¦ä¸€å°æœºå™¨è·‘,å› æ­¤è¦ä¿å­˜æœºå™¨ç¯å¢ƒ,ä¿å­˜åˆ°ç‰©ç†åœ°å€ä¸Š

â—æ‹”ç”µæºå°±æ˜¯ç”³è¯·ä¸€å°æ–°çš„æœºå™¨,å‡†å¤‡è¿è¡Œæ–°çš„æœºå™¨,é€šè¿‡å¼€æŸœé—¨å·²ç»ä¿å­˜äº†æ—§çš„æœºå™¨çš„å¯„å­˜å™¨ç¯å¢ƒ,ä½†æ˜¯æ–°çš„æœºå™¨ä¹Ÿéœ€è¦newä¸€ä¸ªç©ºé—´æ¥ä¿å­˜å¯„å­˜å™¨ç¯å¢ƒ,ä¹Ÿéœ€è¦ä¸€ä¸ªç‰©ç†åœ°å€ä½œä¸ºå‚æ•°

â—é€‰ä¸­æœºå™¨ å°±æ˜¯ç¯å¢ƒè½¬åˆ°æ–°ç”³è¯·çš„æœºå™¨ç¯å¢ƒ

â—è£…æœºå°±æ˜¯è£…æ˜¾å¡,è£…cpu,è£…ä¸»æ¿ç­‰,å°±æ˜¯è®¾ç½®å¯„å­˜å™¨ç¯å¢ƒ,å¯„å­˜å™¨ç¯å¢ƒæ˜¯ä¸€ä¸ªç»“æ„ä½“,æˆ‘ä»¬æ— æ³•æ“ä½œ,å› ä¸ºåç§»å¯èƒ½éšç€ç‰ˆæœ¬çš„å˜åŒ–è€Œå˜åŒ–,æ‰€ä»¥intel æä¾›äº† vmwrite æŒ‡ä»¤,é€šè¿‡å‚æ•°æ¥å†™å¯„å­˜å™¨é‡Œé¢å“ªä¸ªçš„å€¼

â—å¼€æœº,è¿è¡Œæ–°æœºå™¨,çœŸå®çš„cpuå°±ä¼šèµ°æ–°æœºå™¨çš„æ±‡ç¼–ä»£ç ,åŒ…æ‹¬å¯„å­˜ç¯å¢ƒæˆ‘ä»¬è®¾ç½®äº†,EIPä¹Ÿè®¾ç½®äº†,ä»–è‡ªç„¶çŸ¥é“å»å“ªè·‘ä»£ç 

â—æ‹”ç”µæº å°±æ˜¯ ä¸ç”¨è¿™å°æœºå™¨

â—å…³æŸœé—¨å°±æ˜¯å›åˆ°åŸæ¥çš„æœºå™¨

â—ä¸Šé”

â—å¯ä»¥ä¸å…³æŸœé—¨,ä¸æ‹”ç”µæº,ä¸å…³é”é‚£ä¹ˆè¿™å°æœºå™¨å°±ä¼šä¸€ç›´è·‘,è¿™å°æœºå™¨åªè¦äº§ç”Ÿäº†ä¸€ä¸ªäº‹ä»¶,å°±ä¼šä¸€ä¸ª  vm-exitäº‹ä»¶,å°±ä¼šé€šçŸ¥æˆ‘ä»¬

â—é€šè¿‡ä¸Šé¢æµç¨‹å¯ä»¥é‡å¤åˆ›å»ºæœºå™¨,é€šè¿‡ vmptrload æ¥æŒ‡æ˜è¿è¡Œçš„æœºå™¨,å‚äº‹å°±æ˜¯æœºå™¨ç¯å¢ƒ 

â—å½“æˆ‘ä»¬å¼€æœºç”¨è¿™å°è™šæ‹Ÿæœºçš„æ—¶å€™,åªè¦æ²¡å…³é”,åˆ«äººè®²æ— æ³•è¿›å…¥ VT ,å› æ­¤ä¸€ä¸ªCPU,ä¸èƒ½åŒæ—¶2ä¸ªæˆ–è€…å¤šä¸ªè¿›å…¥VT

â—å¦‚æœå¤šæ ¸CPU,å°±å¯ä»¥åŒæ—¶è®©å¤šä¸ªæœºå™¨è¿›å…¥VT,ä¸€æ ¸å¯¹åº”ä¸€å°

â—è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å†™ä»£ç æ•…æ„ä¸é€€å‡ºVT, å°±æ˜¯ è¿›å…¥ VTå•¥ä¹Ÿä¸å¹²,å°±æ˜¯ä¸é€€å‡º,è¿™æ ·å…¶ä»–äººå°±æ— æ³•è¿›å…¥VT,æœ‰äº›æ€è½¯å°±æ˜¯è¿™ä¹ˆåšçš„

â—æ€è½¯æ¯”ç—…æ¯’å¯åŠ¨æ—¶é—´æ—©,å› æ­¤ç—…æ¯’æŠ¢ä¸è¿‡æ€è½¯,é™¤éå…ˆè£…ç—…æ¯’,å†è£…æ€è½¯

â—è¿™æ ·å…¶ä»–äººå°±æ²¡åŠæ³•ç”¨VTæ”»å‡»æˆ‘ä»¬

